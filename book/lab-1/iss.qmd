# Design A Simple ISA Simulator

## What is ISA Simulator (ISS)?

When discussing RISC-V and its instructions, people often imagine a physical processor circuit capable of executing them. However, building an actual digital processor is usually a time-consuming task. To prototype ideas more quickly, we can instead build a simulator.

Designing real hardware like a CPU typically requires Hardware Description Languages (HDLs), such as Verilog or SystemVerilog, which are relatively low-level and detail-oriented. In contrast, a simulator can be developed using general-purpose programming languages like C, C++, or Python. Simulators also abstract away many low-level concerns such as timing information and register-level transactions, allowing us to save a significant amount of development time.

In this lab, our goal is to build a simulator that mimics the behavior of a RISC-V machine. Such a tool is commonly referred to as an ***Instruction Set Architecture (ISA) Simulator***, or ***ISS*** for short. The role of the ISS is straightforward: it recognizes RISC-V instructions and executes them accordingly.

## Overall Architecture of Example ISS {#sec-iss-overall-arch}

The overall execution flow of the ISS itself can be abstracted into three steps: Fetch, Decode and Execute.
In the fetch stage, the ISS will try to read the memory (ROM or RAM) to get the instruction to be executed.
The read instruction will be decoded in the decode stage. The output of the decode stage is the `inst_enum_t` which indicates what the current instruction is. Finally, both `inst_fields_t` and `inst_enum_t` will be send to the execution stage to execute the fetched instruction. The most important thing is that the update of ***architectural states*** only happens at the execution stage. In both fetch and decode stages, the ISS does not change its architectural states. 

![](images/iss.png){fig-align="center"}

In addition to the ISS itself, we also provide eight public APIs. These APIs make the ISS easier to test and integrate. More importantly, they are essential for reference-model-based verification, as described in @sec-cross-verify.

## Detailed Architecture of Example ISS

### Definine Architectural States

As a ISA Simulator, the most important thing is to parse the input RISC-V instruction and execute it. Execution means the possibility to change the ***architectural states***. In RISC-V ISA, especially for RV32I we want to implement, the architectural state mainly consists of two parts: ***Program Counter*** (PC) and ***General Purpose Registers*** (a.k.a. Register File).

```{.cpp title="arch.h"}
#include <stdint.h>

// common types
typedef uint8_t byte_t;
typedef uint32_t reg_t;
typedef uint32_t addr_t;

// architectural states of a ISS
typedef struct arch_state {
    reg_t current_pc; // Program Counter
    reg_t gpr[32];    // General Purpose Registers (x0-x31)
} arch_state_t;
```

In our implementation, we define a user-defined type called `arch_state_t`, which is composed of PC and GPRs.
As for the main memory, we classify it into the generic memory map devices. Hence, this is the reason why the main memory is not included into the `arch_state_t`.

### Some Pre-Defined Information

In order to develop the ISS in a more convenient way, we must define some user-defined types (i.e., some special data structures) to make our code more elegant and readable.

Firstly, we define `inst_fields_t` by usgin `union` in C language to make the decoding of instruction more convinent.

```cpp
/* define 6 (4 base + 2 extended) types of formats of instructions in RV64I */
typedef union {
    struct {
        uint32_t opcode : 7;
        uint32_t rd : 5;
        uint32_t func3 : 3;
        uint32_t rs1 : 5;
        uint32_t rs2 : 5;
        uint32_t func7 : 7;
    } R_TYPE;
    struct {
        uint32_t opcode : 7;
        uint32_t rd : 5;
        uint32_t func3 : 3;
        uint32_t rs1 : 5;
        int32_t imm_11_0 : 12;
    } I_TYPE;
    struct {
        uint32_t opcode : 7;
        uint32_t imm_4_0 : 5;
        uint32_t func3 : 3;
        uint32_t rs1 : 5;
        uint32_t rs2 : 5;
        int32_t imm_11_5 : 7;
    } S_TYPE;
    struct {
        uint32_t opcode : 7;
        uint32_t rd : 5;
        int32_t imm_31_12 : 20;
    } U_TYPE;
    struct {
        uint32_t opcode : 7;
        uint32_t imm_11 : 1;
        uint32_t imm_4_1 : 4;
        uint32_t func3 : 3;
        uint32_t rs1 : 5;
        uint32_t rs2 : 5;
        uint32_t imm_10_5 : 6;
        int32_t imm_12 : 1; // highest imm
    } B_TYPE;
    struct {
        uint32_t opcode : 7;
        uint32_t rd : 5;
        uint32_t imm_19_12 : 8;
        uint32_t imm_11 : 1;
        uint32_t imm_10_1 : 10;
        int32_t imm_20 : 1; // highest imm
    } J_TYPE;
    uint32_t raw;
} inst_fields_t;
```

For example, there is a `add, x1, x2, x3` instruction, and we already know that it is a R-Type format instruction.
We can decode the ADD instruction as following:

```cpp
// set the inst to be `add x1, x2, x3`
inst_fields_t inst = {};
inst.raw = 0x003180b3;

// if we want to get opcode, func3, func7, rs1, rs2 and rd
unsigned opcode = inst.R_TYPE.opcode;
unsigned func3 = inst.R_TYPE.func3;
unsigned func7 = inst.R_TYPE.func7;
unsigned rs1_index = inst.R_TYPE.rs1;
unsigned rs2_index = inst.R_TYPE.rs2;
unsigned rsd_index = inst.R_TYPE.rd;
```

Secondly, we define `inst_enum_t` by using `enum` in C language to enumerate all the instructions we must implement in this lab.

```cpp
/*
 * Enumerate 37 instructions in total
 * It should be generated in ISS_decode() stage
 */
typedef enum {
    // OP
    inst_add,
    inst_sub,
    inst_sll,
    inst_slt,
    inst_sltu,
    inst_xor,
    inst_srl,
    inst_sra,
    inst_or,
    inst_and,
    // OP-IMM
    inst_addi,
    inst_slti,
    inst_sltiu,
    inst_xori,
    inst_ori,
    inst_andi,
    inst_slli,
    inst_srli,
    inst_srai,
    // LOAD
    isnt_lb,
    inst_lh,
    inst_lw,
    inst_lbu,
    inst_lhu,
    // STORE
    inst_sb,
    inst_sh,
    inst_sw,
    // BRANCH
    inst_beq,
    inst_bne,
    inst_blt,
    inst_bge,
    inst_bltu,
    inst_bgeu,
    // JAL
    inst_jal,
    // JALR
    inst_jalr,
    // AUIPC
    inst_auipc,
    // LUI
    inst_lui,
} inst_enum_t;
```

The reason we define `inst_enum_t` is that it can simplify the implementation of execute stage of the ISS.
With `inst_enum_t`, the execute stage can be implemented with a large `case` statement in C language, which is straightforward and easy to understand.
For example, one might implement the `ISS_decode()` as following:

```cpp
inst_enum_t inst_enum;
switch (inst_enum) {
	inst_add: {
		// perform addition
		break;
	}
	inst_sub: {
		// perform substraction
		break;
	}
	...
	...
	...
}
```

### Break Down the ISS Implementation from A [Top-Down Approach]{.mark}

In the beginning, we have to realize the definition of structure `ISS` and `Core`.

```cpp
struct iss {
    // core part (RISC-V processor)
    Core core;

    // MMIO devices
    ROM rom_mmio;
    MainMem main_mem_mmio;
    TextBuffer text_buffer_mmio;
    Halt halt_mmio;
};

typedef struct {
    Tick super; // inherit from parent class

    // internal states of core (includes memory map object)
    arch_state_t arch_state; // RISC-V architectural states
    reg_t new_pc;            // helper data member for next-pc calculation
    MemoryMap mem_map;       // memory map which contains all MMIO devices (with
                             // LOAD/STORE capability)
} Core;
```

We then look at the overall execution loop of the ISS:

```cpp
void ISS_step(ISS *self, unsigned long n_step) {
    for (unsigned i = 0; i < n_step; i++) {
        // check halt flag
        if (unlikely(self->halt_mmio.halt_flag == true)) {
            return;
        }
        // tick all tickable devices (includes core itself)
        Tick_tick(&self->core.super);
        Tick_tick(&self->text_buffer_mmio.tick_super);
    }
}
```

The ISS check the halt flag at the first to determine whether to stop the current step execution.
If the halt flag is false, the ISS will then try to *tick* one of its data member called `core` and `text_buffer_mmio`.
Let's examine the implementation of tick function for `core`:

```cpp
DECLARE_TICK_TICK(Core) {
    Core *self_               = container_of(self, Core, super);
    inst_fields_t inst_fields = Core_fetch(self_);
    inst_enum_t inst_enum     = Core_decode(self_, inst_fields);
    Core_execute(self_, inst_fields, inst_enum);
    Core_update_pc(self_);
}
```

As you can see, it contains three main steps for a step of ISS execution: `Core_fetch()`, `Core_decode()` and `Core_execute()`. After these three steps are completed, the ISS will update the current PC to the new PC value via `Core_update_pc()`.

::: {.callout-tip}
As for `container_of()` macro, you can refer to @sec-linux-oop-macro.
:::

#### Fetch

```cpp
static inst_fields_t Core_fetch(Core *self) {
    // fetch instruction according to self->arch_state.current_pc
    byte_t inst_in_bytes[4] = {};
    MemoryMap_generic_load(&self->mem_map, self->arch_state.current_pc, 4, inst_in_bytes);
    // transformation
    inst_fields_t ret = {};
    ret.raw |= (reg_t)inst_in_bytes[0];
    ret.raw |= (reg_t)inst_in_bytes[1] << 8;
    ret.raw |= (reg_t)inst_in_bytes[2] << 16;
    ret.raw |= (reg_t)inst_in_bytes[3] << 24;
    return ret;
}
```

In the fetch stage, the *core* fetch the raw binary instruction via `MemoryMap_generic_load()` function which accesses to the one of the memory devices in memory map. (The core access to the main memory at here.)

#### Decode

#### Execute

### Object-Oriented in The ISS: `Tick` and `AbstractMem` {#sec-oop-in-iss}

In our ISS, we model the simulator as like a ***clock-trigger*** machine. Because of the OOP design paradigm, we want to utilize the capability of inheritance to express our code structure.
Consequently, we define a base class which is called `Tick`, and the definition of `Tick` is as following:

```{.cpp filename="tick.h"}
// parent class for general ticked devices
struct TickVtbl;
typedef struct {
    struct TickVtbl const *vtbl;
} Tick;

// define virtual table
struct TickVtbl {
    void (*tick)(Tick *const self);
};

// define public APIs
extern void Tick_ctor(Tick *const self);
extern void Tick_tick(Tick *const self);

// helper macros for children classes
#define SIGNATURE_TICK_TICK(cls) cls##_Tick_tick
#define DECLARE_TICK_TICK(cls) void (SIGNATURE_TICK_TICK(cls))(Tick *const self)
```

```{.cpp filename="tick.c"}
#include "tick.h"

#include <stdio.h>
#include <assert.h>
#include <stdbool.h>

static void _tick(Tick *const self) {
    assert(false);
    fprintf(stderr, "%s\n", "Please implement the virtual function!");
}

void Tick_ctor(Tick *const self) {
    assert(self != NULL);
    static struct TickVtbl const vtbl = { .tick = &_tick };
    self->vtbl                        = &vtbl;
}

void Tick_tick(Tick *const self) {
    assert((self != NULL) && (self->vtbl != NULL));
    self->vtbl->tick(self);
}
```

::: {.callout-tip}
If you are confused about the `const` keyword in C language, please refer to @const-keyword.
:::

### Generic Memory-Mapped Load/Store

In order to make the ISS support ***Memory-Mapped I/O Control***, we implement a class called `MemoryMap` and some other helper data structures and functions.

```{.cpp title="mem_map.h"}
#include "abstract_mem.h"
#include "arch.h"

typedef struct {
    addr_t first;
    addr_t second;
} addr_pair_t;
typedef struct {
    addr_pair_t addr_bound;
    AbstractMem *device_ptr;
} mmap_unit_t;

typedef struct {
    unsigned num_device;
    mmap_unit_t *memory_map_arr;
} MemoryMap;

/* Public APIs */
// member functions
extern int MemoryMap_ctor(MemoryMap *self);
extern void MemoryMap_dtor(MemoryMap *self);
extern int MemoryMap_add_device(MemoryMap *self, mmap_unit_t new_device);
// generic load/store APIs
extern void MemoryMap_generic_load(MemoryMap *self, addr_t base_addr, unsigned length, byte_t *buffer);
extern void MemoryMap_generic_store(MemoryMap *self, addr_t base_addr, unsigned length, const byte_t *ref_data);
```

## How To Build The Lab 2 Code Template

After accepting Lab 2 on the GitHub Classroom, you should have your own repository which contains the code template for lab 2.
Please clone the owned repository into your docker development environment.

For example, if my folder is called `lab-2`, then I can build the code template as following:

```shell
$ cd lab-2
$ mkdir build && cd build
$ cmake ..
$ make -j
```

After building the code templace TA provides, you can now run the unit tests by using the following command:

```shell
$ ctest
```