# Introduction to RISC-V ISA

::: {.callout-tip}
If you are interested in how RISC-V is developed and the art of RISC-V, you can read the book @riscv-reader.
:::

::: {.callout-warning}
In this lecture, it only covers the unprivileged architecture of RISC-V ISA, while there are privileged architecture in addition.
For more information about priv. architecture, please refer to the specification of privileged architecture @riscv-spec-priv.
:::

## The Software/Hardware Interface - ISA

As stated in @sec-computer, the ISA serves as the interface between software and hardware. The term “interface” here represents a level of **abstraction**. In other words, software developers do not need to understand the low-level details of hardware implementation as long as the ISA requirements are satisfied. Similarly, hardware designers do not need to fully understand the complexities of the software stack, as long as the hardware correctly supports the ISA.

This abstraction allows both sides to evolve **independently**: new hardware implementations can be developed without requiring changes to existing software, and new software can run on different generations of hardware, provided they share the same ISA. Only when performance considerations or specialized optimizations are involved does a deeper cross-layer understanding become necessary.

> We can solve any problem by introducing an extra level of indirection. <br>
> --- The fundamental theorem of software engineering (FTSE)

## Introduction to RISC-V

> introduce the modular design of RISC-V, and CISC vs. RISC

## Architectural Registers for Base Integer Instruction Set

Register are the most important part for almost any processor. Mote precisely, the [***architectural register***]{.mark} are the most important component inside a processor which records the current states of the processor.
In RISC-V base integer set, there are 32 ***general purpose registers***, which are used for **any** purpose. However, the register `x0` should always be zero according the the ISA specification @riscv-spec-unpriv.
In addition, there is one special register which is called ***Program Counter*** or ***PC*** for short. The duty of PC is to record the memory address of the current instruction to be executed.

Here is the list of all 32 general purpose registers:

|*Register*  | *ABI*       | *Use by convention*                   | *Preserved?*|
|------------|-------------|---------------------------------------|-------------|
|x0          | zero        | hardwired to 0, ignores writes        | _n/a_       |
|x1          | ra          | return address for jumps              | no          |
|x2          | sp          | stack pointer                         | yes         |
|x3          | gp          | global pointer                        | _n/a_       |
|x4          | tp          | thread pointer                        | _n/a_       |
|x5          | t0          | temporary register 0                  | no          |
|x6          | t1          | temporary register 1                  | no          |
|x7          | t2          | temporary register 2                  | no          |
|x8          | s0 _or_ fp  | saved register 0 _or_ frame pointer   | yes         |
|x9          | s1          | saved register 1                      | yes         |
|x10         | a0          | return value _or_ function argument 0 | no          |
|x11         | a1          | return value _or_ function argument 1 | no          |
|x12         | a2          | function argument 2                   | no          |
|x13         | a3          | function argument 3                   | no          |
|x14         | a4          | function argument 4                   | no          |
|x15         | a5          | function argument 5                   | no          |
|x16         | a6          | function argument 6                   | no          |
|x17         | a7          | function argument 7                   | no          |
|x18         | s2          | saved register 2                      | yes         |
|x19         | s3          | saved register 3                      | yes         |
|x20         | s4          | saved register 4                      | yes         |
|x21         | s5          | saved register 5                      | yes         |
|x22         | s6          | saved register 6                      | yes         |
|x23         | s7          | saved register 7                      | yes         |
|x24         | s8          | saved register 8                      | yes         |
|x25         | s9          | saved register 9                      | yes         |
|x26         | s10         | saved register 10                     | yes         |
|x27         | s11         | saved register 11                     | yes         |
|x28         | t3          | temporary register 3                  | no          |
|x29         | t4          | temporary register 4                  | no          |
|x30         | t5          | temporary register 5                  | no          |
|x31         | t6          | temporary register 6                  | no          |
|pc          | _(none)_    | program counter                       | _n/a_       |

In order to implement the simulator which can simulate a RISC-V machine, the simulator must implements these registers inside.

::: {.callout-note}
You might note that there are two special columns in the table called *ABI* and *Preserved*. These entries are related to the concepts of *Application binary Interface (ABI)*.
The introduction to ABI will be placed at the @sec-riscv-abi, and we will skip this part at the moment.
:::

## RISC-V Instruction Encoding Formats

When it comes to ISA instructions, the encoding for the instruction is always the first aspect to address.
The way an instruction is encoded has a significant impact on how a processor is designed, particularly for the instruction decoder.
Similarly, it affects how we implement the decode logic when building the ISA simulator.
Therefore, getting familiar with RISC-V instruction formats is one of the essential tasks.

In RISC-V, there are **four** base instruction formats and **two** extended formats. The additional two formats are mainly related to the handling of immediates.

### Base Instruction Format

![](images/r-format.png){fig-align="center"}

![](images/i-format.png){fig-align="center"}

R-Type and I-Type are two of the four base instruction formats which do not have extended format. Besides, there are two formats S-Type and U-Type which have extended formats. The extended formats for S-Type and U-Type are B-Type and J-Type respectively.

![](images/s-format.png){fig-align="center"}

![](images/u-format.png){fig-align="center"}

According to the RISC-V specification for unprivileged architecture @riscv-spec-unpriv:

> The RISC-V ISA keeps the source (rs1 and rs2) and destination (rd) registers at the same position in all formats to simplify decoding.
>
> Except for the 5-bit immediates used in CSR instructions (Chapter 6), immediates are always sign-extended, and are generally packed towards the leftmost available bits in the instruction and have been allocated to reduce hardware complexity.
>
> In particular, the sign bit for all immediates is always in bit 31 of the instruction to speed sign-extension circuitry.

We could find some important properties:

1. The source (rs1 and rs2) and destination (rd) registers are at the same position in all formats (except for CSR instructions)
2. Immediates are always sign-extended
3. The sign bit for all immediates is always in bit 31 of the instruction

These great ideas greatly reduce the hardware complexity of designing a instruction decoder inside a real RISC-V processor.

### Immediate Encoding Variants

![S-Type Format](images/s-format.png){fig-align="center"}

![B-Type Format](images/b-format.png){fig-align="center"}

As what we just said, there are two extended instruction format B-Type and J-Type.
The B-Type format is based on S-Type format, while how the immediates are encoded is different.
According to @riscv-spec-unpriv:

> The only difference between the S and B formats is that the 12-bit immediate field is used to encode branch offsets in multiples of 2 in the B format. Instead of shifting all bits in the instruction-encoded immediate left by one in hardware as is conventionally done, the middle bits (imm[10:1]) and sign bit

![U-Type Format](images/u-format.png){fig-align="center"}

![J-Type Format](images/j-format.png){fig-align="center"}

Similarly, J-Type format is based on U-Type format. According to @riscv-spec-unpriv:

> The only difference between the U and J formats is that the 20-bit immediate is shifted left by 12 bits to form U immediates and by 1 bit to form J immediates. The location of instruction bits in the U and J format immediates is chosen to maximize overlap with the other formats and with each other.

Let's look these different immediates in another point of view:

![Immediate types](images/imm-produced.png){fig-align="center"}

> Immediate types shows the immediates produced by each of the base instruction formats, and is
labeled to show which instruction bit (inst[y]) produces each bit of the immediate value.
> The fields are labeled with the instruction bits used to construct their value. Sign extensions always uses inst[31].
>
> --- From @riscv-spec-unpriv

## RV32I Instructions

We can divide instructions in RV32I base integer instruction set into several parts, including (a) **integer computational instructions**, (b) **control transfer instructions**, (c) **load and store instructions**, (d) **memory ordering instructions** and (e) **environment call and breakpoint instructions**. However, we do not cover (d) and (e) in this lecture.

Before we go into the details about each instruction, let's take a look on ***opcode map***:

![Opcode Map from @riscv-spec-unpriv](images/opcode-map.png){fig-align="center"}

For those instructions we must implement in the ISA Simulator, we have to recognize the following opcodes:

- OP
  - **Register-Register** Operations
- OP-IMM
  - **Register-Immediate** Operations
- LOAD
  - Load Operations
- STORE
  - Store Operations
- BRANCH
  - **Conditional** Branches
- JAL
  - Only for JAL instruction, which is **Unconditional** Jump
- JALR
  - Only for JALR instruction, which is **Unconditional** Jump
- LUI
  - Only for LUI instruction
- AUIPC
  - Only for AUIPC instruction

All the **37** instructions we must implement all belong to one of these opcodes.
Let's talk about these 37 instructions in the perspective of their functionality.

### Integer Computational Instructions

#### Integer Register-Immediate Operations

![](images/op-imm-1.png){fig-align="center"}

> ADDI adds the **sign-extended 12-bit immediate** to register *rs1*. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.
> ADDI *rd*, *rs1*, *0* is used to implement the MV *rd*, *rs1* assembler pseudoinstruction.
>
> SLTI (set less than immediate) places the value 1 in register rd if register rs1 is less than the **sign-extended immediate** when both are treated as signed numbers, else 0 is written to rd.
SLTIU is similar but compares the values as **unsigned numbers** (i.e., [the immediate is first sign-extended to XLEN bits then treated as an unsigned number]{.mark}).
> Note, SLTIU *rd*, *rs1*, *1* sets *rd* to 1 if *rs1* equals zero, otherwise sets *rd* to 0 (assembler pseudoinstruction SEQZ *rd*, *rs*).
>
> ANDI, ORI, XORI are logical operations that perform bitwise AND, OR, and XOR on register *rs1* and the **sign-extended 12-bit immediate** and place the result in *rd*.
Note, XORI *rd*, *rs1*, *-1* performs a bitwise logical inversion of register *rs1* (assembler pseudoinstruction NOT *rd*, *rs*).
>
> --- From Chapter 2.4.1 in RISC-V ISA Spec @riscv-spec-unpriv

The first classes of OP-IMM instructions are the general arithmetic instructions which perform common operations such as addition, logical operations and **conditional set operation**.

![](images/op-imm-2.png){fig-align="center"}

> Shifts by a constant are encoded as a specialization of the I-type format. The operand to be shifted is in rs1, and the shift amount is encoded in the lower 5 bits of the I-immediate field. The right shift type is encoded in bit 30. SLLI is a logical left shift (zeros are shifted into the lower bits); SRLI is a logical right shift (zeros are shifted into the upper bits); and SRAI is an arithmetic right shift (the original sign bit is copied into the vacated upper bits).
>
> --- From Chapter 2.4.1 in RISC-V ISA Spec @riscv-spec-unpriv

The second class of OP-IMM instructions are related to shift operations, including ***shift-right-logically***, ***shift-right-arithmetically***, and ***shift-left-logically***.

![](images/op-imm-3.png){fig-align="center"}

Third class of OP-IMM instructions are LUI and AUIPC instructions.

> LUI (load upper immediate) is used to build 32-bit constants and uses the U-type format. LUI places the 32-bit U-immediate value into the destination register rd, filling in the lowest 12 bits with zeros.
>
> AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the address of the AUIPC instruction, then places the result in register rd.
>
> --- From Chapter 2.4.1 in RISC-V ISA Spec @riscv-spec-unpriv

#### Integer Register-Register Operations

![](images/op.png){fig-align="center"}

#### NOP Instruction

![](images/nop.png){fig-align="center"}

### Control Transfer Instructions

#### Unconditional Jumps

![](images/jal.png){fig-align="center"}

![](images/jalr.png){fig-align="center"}

#### Conditional Branches

![](images/branch.png){fig-align="center"}

### Load and Store Instructions

![](images/load.png){fig-align="center"}

![](images/store.png){fig-align="center"}

## RV32I Instruction List

::: {.callout-note title="Notes on Pseudocode Annotation"}
For a given number (or register) `A`, it is unsigned number if it is annotated as `unsigned(A)`. Otherwise, it is signed number.
:::

| Instruction Name | Opcode Map | [Semantics]{.mark} (Described in Pseudocode)    |
|------------------|------------|-------------------------------------------------|
| LUI              | LUI        | `rd = imm << 12`                                |
| AUIPC            | AUIPC      | `rd = PC + (imm << 12)`                         |
| JAL              | JAL        | `rd = PC + 4; PC += imm`                        |
| JALR             | JALR       | `rd = PC + 4; PC = rs1 + imm`                   |
| BEQ              | BRANCH     | `if(rs1 == rs2) PC += imm`                      |
| BNE              | BRANCH     | `if(rs1 != rs2) PC += imm`                      |
| BLT              | BRANCH     | `if(rs1 < rs2) PC += imm`                       |
| BGE              | BRANCH     | `if(rs1 >= rs2) PC += imm`                      |
| BLTU             | BRANCH     | `if(unsigned(rs1) < unsigned(rs2)) PC += imm`   |
| BGEU             | BRANCH     | `if(unsigned(rs1) >= unsigned(rs2)) PC += imm`  |
| LB               | LOAD       | `rd = M[rs1+imm][0:7]`                          |
| LH               | LOAD       | `rd = M[rs1+imm][0:15]`                         |
| LW               | LOAD       | `rd = M[rs1+imm][0:31]`                         |
| LBU              | LOAD       | `rd = M[rs1+imm][0:7]`                          |
| LHU              | LOAD       | `rd = M[rs1+imm][0:15]`                         |
| SB               | STORE      | `M[rs1+imm][0:7] = rs2[0:7]`                    |
| SH               | STORE      | `M[rs1+imm][0:15] = rs2[0:15]`                  |
| SW               | STORE      | `M[rs1+imm][0:31] = rs2[0:31]`                  | 
| ADDI             | OP-IMM     | TODO                       |
| SLTI             | OP-IMM     | TODO                       |
| SLTIU            | OP-IMM     | TODO                       |
| XORI             | OP-IMM     | TODO                       |
| ORI              | OP-IMM     | TODO                       |
| ANDI             | OP-IMM     | TODO                       |
| SLLI             | OP-IMM     | TODO                       |
| SRLI             | OP-IMM     | TODO                       |
| SRAI             | OP-IMM     | TODO                       |
| ADD              | OP         | TODO                       |
| SUB              | OP         | TODO                       |
| SLL              | OP         | TODO                       |
| SLT              | OP         | TODO                       |
| SLTU             | OP         | TODO                       |
| XOR              | OP         | TODO                       |
| SRL              | OP         | TODO                       |
| SRA              | OP         | TODO                       |
| OR               | OP         | TODO                       |
| AND              | OP         | TODO                       |

::: {.callout-caution}
We did not actually cover __all__ RV32I instructions in this lab. There are three instructions we do not cover: FENCE, EBREAK and ECALL instructions.
:::
