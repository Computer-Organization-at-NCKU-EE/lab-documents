# Pipeline CPU Micro-Architecture Design {#sec-pipeline-microarch}
Each component in our pipeline CPU design

## Pipeline Registers: 

![pipeline_register](images/pipeline_reg.png){width=90% fig-align="center"}

### Why do we need Pipeline Registers? 

#### Core idea  

Pipeline registers are the boundaries that [**split a long combinational datapath into stages (IF/ID/EX/MEM/WB)**]{.mark}. Each register latches data and control between stages so multiple instructions can **overlap in time** while preserving correct program order.

#### What they carry  

source operands (or store data), immediates, `rd/rs1/rs2`, `PC/PC+4` (as needed), and **all control bits** required later (e.g., `RegWrite`, `MemRead/Write`, `MemToReg`, ALU-op). Carrying control forward lets a younger instruction act correctly several cycles after decode. (設計完再改變數名)

#### Frequency benefit and cost

By cutting the path into stages, the clock period becomes
$$
T_{\mathrm{clk}} \approx \max_i D_i \;+\; t_{\mathrm{reg}},
$$
where $D_i$ is the delay of stage $i$ and $t_{\mathrm{reg}}$ is the register overhead
(clk-to-Q, setup, clock skew). Staging **raises the maximum clock frequency**
(throughput $\uparrow$), but the **latency per instruction** becomes
$$
L_{\mathrm{pipe}} = N \cdot T_{\mathrm{clk}},
$$
which is typically larger than the single-cycle latency
$L_{\mathrm{single}} = \sum_i D_i$.

::: {.callout-warning title="What you pay"}
- Higher **latency** for one instruction ($N$ stages × $T_{\mathrm{clk}}$)
- Extra register overhead $t_{\mathrm{reg}}$ per stage
- More power/area and control complexity (stall/flush/forward)
- Deeper pipelines → larger **misprediction penalty** (more bubbles on redirect)
:::

**Example:**  Stage delays = [10, 6, 6, 10, 3] ns, and $t_{\mathrm{reg}}=1$ ns.

- Single-cycle:  $T_{\mathrm{single}} = 35$ ns → throughput = 1/35 ins/ns, latency = 35 ns.
- 5-stage pipe:  $T_{\mathrm{clk}} = \max = 10 + 1 = 11$ ns  
  Latency per instruction $L_{\mathrm{pipe}} = 5 \times 11 = 55$ ns (↑),  
  Throughput ≈ 1/11 ins/ns (↑).

#### Control point for correctness

[**Pipeline registers are where we apply hazard control**]{.mark}:

- **stall**: hold **PC** and **IF/ID** (keep = `output ≤ output`) to wait for data;
- **bubble / flush**: write a **NOP** into **ID/EX** (bubble) or into **IF/ID** and **ID/EX** (flush on redirect) so wrong-path or too-early work has **no architectural effects**.

::: {.callout-warning title="Trade-offs to remember"}
- Registers are not free: $t_{\mathrm{reg}}$ and extra power/area are the price for higher frequency.
- A scalar pipeline’s **ideal IPC is still 1**; bubbles from hazards (RAW load–use, mispredicted branches, etc.) reduce the realized IPC below 1.
:::

---

### Control policy
- **stall**: a one-cycle *hold* (typically the **load–use RAW** case). Pause the front end until data can be forwarded.
- **jb (redirect)**: control-flow change (taken branch/jump or misprediction). Flush younger wrong-path ops.
- **others**: normal operation (no stall, no redirect).
- **keep (`output ≤ output`)**: hold the register value; do not advance this stage.
- **flush (`output ≤ nop`)**: convert this stage to a **NOP** (no architectural effects).
- **bubble (`output ≤ nop`)**: intentionally *insert* a NOP at this stage so older stages can drain.
  
---


| Register | stall                               | jb (redirect)                  | others              |
|:--------:|:------------------------------------|:-------------------------------|:--------------------|
| **Reg_PC** | **keep** *(output ≤ output)*         | **output ≤ input** *(next_pc)* | **output ≤ input**  |
| **Reg_D**  | **keep** *(output ≤ output)*         | **flush** *(output ≤ nop)*     | **output ≤ input**  |
| **Reg_E**  | **bubble** *(output ≤ nop)*          | **flush** *(output ≤ nop)*     | **output ≤ input**  |
| **Reg_M**  | **output ≤ input**                   | **output ≤ input**             | **output ≤ input**  |
| **Reg_W**  | **output ≤ input**                   | **output ≤ input**             | **output ≤ input**  |

---

### Worked timelines

#### (A) Load–Use stall (classic 1-bubble case)

| Cycle                | IF                 | ID                  | EX                         | MEM | WB |
|:---------------------|:-------------------|:--------------------|:---------------------------|:----|:---|
| t (before stall)     | `I3`               | `I2 (use x1)`       | `I1 (LOAD x1)`             | `I0`| `-`|
| t+1 (after control)  | `I3`               | `I2 (use x1)`       | `bubble`                   | `I1`| `I0`|
| t+2                  | `I4`               | `I3`                | `I2 (fwd from MEM/WB)`     | `I1`| `I0`|

: **Load–use stall timeline** {#tbl-loaduse}

::: {.callout-tip title="Stall control for Table \\@tbl-loaduse"}
On a **stall**, fetching/decoding new instructions would push wrong content forward, so **Reg_PC** and **Reg_D** must **keep**. 
To avoid blocking the back end, **Reg_E** emits a **bubble** so MEM/WB can continue and free space.

- `PC`: **keep** (hold)
- `IF/ID`: **keep**
- `ID/EX`: **bubble** (insert NOP)
:::


#### (B) Branch redirect (mispredicted not-taken, actually taken)

| Cycle                   | IF        | ID     | EX                     | MEM | WB |
|:------------------------|:----------|:-------|:-----------------------|:----|:---|
| t (resolve taken in EX) | `I_wrong2`| `I_wrong1` | `Branch (taken)`   | `I1`| `I0`|
| t+1 (after redirect)    | `T0`      | `nop`  | `nop`                  | `I1`| `I0`|

: **Branch redirect timeline** {#tbl-redirect}

::: {.callout-tip title="Redirect control for Table \\@tbl-redirect"}
On a **redirect (jb)**, younger wrong-path instructions must be discarded: **Reg_D** and **Reg_E** **flush**. 
**Reg_PC** loads the **next_pc** (branch/jump target). Older instructions in M/W should finish normally.

- `IF/ID`: **flush** (NOP)
- `ID/EX`: **flush** (NOP)
- `PC`: load **`next_pc`** (the branch target)
:::



## TBD

::: {.callout-tip title="How to predict future branches"}
- Static approach
  - Always predict not-taken
- Dynamic approach
  - 2-bits saturated counter predictor
:::


::: {.callout-tip title="The architecture of a complete branch predictor"}
- The essence of predicting a branch
  - Direction
  - Target PC
- Branch Direction Predictor
- Branch Target Buffer (BTB)
:::

## Lab 4 Assignment

Based on the Lab 3 single-cycle CPU, the following Verilog files are required to implement the Lab 4 pipelined CPU architecture:

• Top.v(CPU.v)
    • ALU.v
    • Decoder.v
    • Imme_Ext.v
    • JB_Unit.v
    • LD_Filter.v
    • RegFile.v
    • Adder.v
    • Reg_PC.v 
    • Mux2.v 
    • Mux3.v 
    • SRAM.v
    • Controller.v 
    • Reg_D.v 
    • Reg_E.v 
    • Reg_M.v 
    • Reg_W.v 

- The problem about pipeline bubbles

  The pipeline bubble will lead to the synchronization issue between ISS (which can be viewed as a single-cycle CPU) and pipeline CPU.
  
  We might have to extend previous reference-model-based verification framework to adapt to pipeline CPU and add some check flags to notify the verification framework to stop ISS and wait for the completion of Pipeline CPU. 
  
  要跟同學說 DiffTest 怎麼改才可以銜接到 Pipeline CPU 上面繼續使用（基本上就是講 ISS 如何 Skip Pipeline Bubbles 以達成 RTL-ISS Synchronization）